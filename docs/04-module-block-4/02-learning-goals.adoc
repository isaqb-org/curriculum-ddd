=== {learning-goals}

// tag::DE[]
Dieser Block vermittelt anhand ausgewählter Beispiele, wie ein Domänenmodell in Software-Architekturen integriert werden kann. Er vermittelt exemplarisch Gemeinsamkeiten und Unterschiede von Domain Driven Design und zwei verwandten Methoden.

[[LZ-4-1]]
==== LZ 4-1: Eine hexagonale Architektur um ein Domänenmodell herum entwerfen
* Die TN können die Unterschiede zwischen einer hexagonalen Architektur und einer Schichtenarchitektur vermitteln.
* **Ports** an den Außenseiten des inneren Hexagons bieten Schnittstellen zur Kommunikation zwischen fachlichem Kern und seiner Umgebung.
* **Adapter**footnote:4[Vgl.: Adapter <<gamma>>] verbinden die Ports mit konkreten Drittsystemen über verschiedene Kommunikationskanäle wie REST-APIs, SOAP, Message Queues oder Db-Connections.
* Die Applikation liegt im Inneren des Hexagons mit dem Domänenmodell als Kern.
* Bei der inneren Modellierung liegt der Fokus auf der Realisierung fachlicher Anforderungen mit Hilfe des Domänenmodells.
* In der äußeren Modellierung liegt der Fokus auf der Bereitstellung fachlicher Operationen und Daten über plattformunabhängige Schnittstellen.
* Das Domänenmodell treibt die Modellierung externer Schnittstellen.
* Ports verwenden Transfer-Klassen anstatt Entities aus dem Domänenmodell. Die TN verstehen, dass dies Versionskonflikte an den Schnittstellen bei Änderungen des Modells entgegenwirkt.

[[LZ-4-2]]
==== LZ 4-2: Zusammenhänge und Abgrenzungen zwischen DDD, WAM und BDD formulieren können
* Die TN kennen Spezifikationen aus BDD und können sie mit der Ubiquitous Language in Zusammenhang bringen. Sie verstehen, dass sich Spezifikationen mit den Wörtern der UL formulieren lassen.
* Die TN verstehen, dass BDD Anforderungen mithilfe der Benutzungsschnittstelle formuliert (Outside-In), und DDD Anforderungen dies über das Domänenmodell ausdrückt (Inside-Out)footnote:5[Vgl.: <<stenberg>>]
* Die TN können die Bausteine von DDD mit den Bausteinen von WAM vergleichen.

// end::DE[]

// tag::EN[]
This section uses selected examples to teach how a domain model can be integrated into software architectures. On the basis of examples, it teaches the similarities and differences between domain-driven design and two related methods.

[[LG-4-1]]
==== LG 4-1: Be able to design a hexagonal architecture for the domain model
* The course participants can explain the differences between a hexagonal architecture and a layered architecture.
* **Ports** to the outer sides of the inner hexagon offer interfaces for communication between the core of the domain and its environment.
* **Adapters**footnote:4[Cf.: Adapter <<gamma>>] connect the ports to specific third-party systems via various communication channels, such as REST APIs, SOAP, message queues or database connections.
* The application lies inside the hexagon with the domain model as the core.
* During internal modeling, the focus lies on implementing domain requirements with the help of the domain model.
* In external modeling, the focus lies on providing domain operations and data via platform-independent interfaces.
* The domain model drives the modeling of external interfaces.
* Ports use transfer classes instead of Entities from the domain model. The course participants understand that this counteracts conflicts between versions at the interfaces in the event of changes to the model.

[[LG-4-2]]
==== LG 4-2: Be able to formulate correlations and distinctions between DDD, T&M Approach and BDD
* The course participants know specifications from BDD and can relate them to the ubiquitous language. They understand that specifications can be formulated with the terms of the ubiquitous language.
* The course participants understand that BDD formulates requirements with the help of the user interface (outside-in), and DDD expresses requirements via the domain model (inside-out)footnote:5[Cf.: <<stenberg>>]
* The course participants can compare the building blocks of DDD with the components of the T&M approach.

// end::EN[]

// tag::REMARK[]
[NOTE]
====
Die einzelnen Lernziele müssen nicht als einfache Aufzählungen mit Unterpunkten aufgeführt werden, sondern können auch gerne in ganzen Sätzen formuliert werden, welche die einzelnen Punkte (sofern möglich) integrieren.
====
// end::REMARK[]
